import fs from "fs/promises";
import path from "path";
import { logger } from "./logger";

// Marker written into auto-generated Dockerfiles so we know to regenerate them
// on the next deploy. User-provided Dockerfiles won't have this line.
const AUTO_GENERATED_MARKER = "# VersionGate:auto-generated";

/**
 * Ensures a Dockerfile exists in the given build context directory.
 *
 * - If a Dockerfile exists WITHOUT the auto-generated marker → user's own file, leave it.
 * - If a Dockerfile exists WITH the marker → stale auto-generated, regenerate it.
 * - If no Dockerfile → generate one.
 *
 * Detection order: buildContextDir first, then repoRootDir, then immediate subdirs.
 * Returns the directory where the Dockerfile was written.
 */
export async function ensureDockerfile(
  buildContextDir: string,
  appPort: number,
  repoRootDir?: string
): Promise<string> {
  const dockerfilePath = path.join(buildContextDir, "Dockerfile");

  try {
    const existing = await fs.readFile(dockerfilePath, "utf-8");
    if (!existing.startsWith(AUTO_GENERATED_MARKER)) {
      // User's own Dockerfile — respect it
      logger.info({ buildContextDir }, "Dockerfile found — skipping generation");
      return buildContextDir;
    }
    // Auto-generated from a previous deploy — fall through to regenerate
    logger.info({ buildContextDir }, "Stale auto-generated Dockerfile detected — regenerating");
  } catch {
    // No Dockerfile — generate one
  }

  // Build candidate list: specified buildContext → repo root → immediate subdirs.
  const root = repoRootDir ?? buildContextDir;
  const dirsToTry: string[] = [buildContextDir];
  if (root !== buildContextDir) dirsToTry.push(root);

  try {
    const entries = await fs.readdir(root, { withFileTypes: true });
    const subdirs = entries
      .filter((e) => e.isDirectory() && !e.name.startsWith(".") && e.name !== "node_modules")
      .map((e) => path.join(root, e.name));
    logger.info({ root, subdirs }, "Scanning repo for project files");
    for (const sub of subdirs) {
      if (!dirsToTry.includes(sub)) dirsToTry.push(sub);
    }
  } catch {
    // readdir failed — skip subdir scan
  }

  for (const dir of dirsToTry) {
    const content = await tryGenerateDockerfile(dir, appPort);
    if (content !== null) {
      const targetDockerfile = path.join(dir, "Dockerfile");
      await fs.writeFile(targetDockerfile, content, "utf-8");
      logger.info({ dir, appPort }, "Dockerfile auto-generated");
      return dir;
    }
  }

  throw new Error(
    "Could not detect project type. Add a Dockerfile to your repository and redeploy."
  );
}

// ── Detector ─────────────────────────────────────────────────────────────────

/** Returns generated Dockerfile content, or null if the project type is undetectable. */
async function tryGenerateDockerfile(repoDir: string, appPort: number): Promise<string | null> {
  // 1. Node.js
  const pkgJsonPath = path.join(repoDir, "package.json");
  try {
    const raw = await fs.readFile(pkgJsonPath, "utf-8");
    const pkg = JSON.parse(raw) as Record<string, unknown>;
    return await buildNodeDockerfile(repoDir, pkg, appPort);
  } catch {
    // not Node
  }

  // 2. Python
  try {
    await fs.access(path.join(repoDir, "requirements.txt"));
    return buildPythonDockerfile(appPort);
  } catch {
    // not Python
  }

  // 3. Go
  try {
    await fs.access(path.join(repoDir, "go.mod"));
    return buildGoDockerfile(appPort);
  } catch {
    // not Go
  }

  return null;
}

// ── Node.js ───────────────────────────────────────────────────────────────────

async function buildNodeDockerfile(
  repoDir: string,
  pkg: Record<string, unknown>,
  appPort: number
): Promise<string> {
  const scripts = (pkg.scripts ?? {}) as Record<string, string>;
  const hasBuild = Boolean(scripts.build);
  const startScript = scripts.start ?? "";
  const buildScript = scripts.build ?? "";

  // Check if start/build scripts explicitly call bun — strongest signal
  const scriptUsesBun = /\bbun\b/.test(startScript) || /\bbun\b/.test(buildScript);
  if (scriptUsesBun) {
    return buildBunDockerfile(appPort, hasBuild);
  }

  // Fall back to lock file detection
  const hasBunLock  = await fileExists(repoDir, "bun.lockb");
  const hasYarnLock = await fileExists(repoDir, "yarn.lock");
  const hasPnpmLock = await fileExists(repoDir, "pnpm-lock.yaml");

  if (hasBunLock)  return buildBunDockerfile(appPort, hasBuild);
  if (hasYarnLock) return buildYarnDockerfile(appPort, hasBuild);
  if (hasPnpmLock) return buildPnpmDockerfile(appPort, hasBuild);
  return buildNpmDockerfile(appPort, hasBuild);
}

function buildNpmDockerfile(appPort: number, hasBuild: boolean): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM node:20-alpine",
    "",
    "WORKDIR /app",
    "",
    "COPY package*.json ./",
    "RUN npm install",
    "",
    "COPY . .",
    "",
    ...(hasBuild ? ["RUN npm run build", ""] : []),
    `EXPOSE ${appPort}`,
    "",
    'CMD ["npm", "start"]',
  ]);
}

function buildYarnDockerfile(appPort: number, hasBuild: boolean): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM node:20-alpine",
    "",
    "WORKDIR /app",
    "",
    "COPY package.json yarn.lock ./",
    "RUN yarn install --frozen-lockfile",
    "",
    "COPY . .",
    "",
    ...(hasBuild ? ["RUN yarn build", ""] : []),
    `EXPOSE ${appPort}`,
    "",
    'CMD ["yarn", "start"]',
  ]);
}

function buildPnpmDockerfile(appPort: number, hasBuild: boolean): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM node:20-alpine",
    "",
    "RUN npm install -g pnpm",
    "",
    "WORKDIR /app",
    "",
    "COPY package.json pnpm-lock.yaml ./",
    "RUN pnpm install --frozen-lockfile",
    "",
    "COPY . .",
    "",
    ...(hasBuild ? ["RUN pnpm run build", ""] : []),
    `EXPOSE ${appPort}`,
    "",
    'CMD ["pnpm", "start"]',
  ]);
}

function buildBunDockerfile(appPort: number, hasBuild: boolean): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM oven/bun:alpine",
    "",
    "WORKDIR /app",
    "",
    "COPY package.json bun.lockb* ./",
    "RUN bun install",
    "",
    "COPY . .",
    "",
    ...(hasBuild ? ["RUN bun run build", ""] : []),
    `EXPOSE ${appPort}`,
    "",
    'CMD ["bun", "run", "start"]',
  ]);
}

// ── Python ────────────────────────────────────────────────────────────────────

function buildPythonDockerfile(appPort: number): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM python:3.11-slim",
    "",
    "WORKDIR /app",
    "",
    "COPY requirements.txt .",
    "RUN pip install --no-cache-dir -r requirements.txt",
    "",
    "COPY . .",
    "",
    `EXPOSE ${appPort}`,
    "",
    'CMD ["python", "app.py"]',
  ]);
}

// ── Go ────────────────────────────────────────────────────────────────────────

function buildGoDockerfile(appPort: number): string {
  return lines([
    AUTO_GENERATED_MARKER,
    "FROM golang:1.22-alpine AS builder",
    "WORKDIR /app",
    "COPY go.mod go.sum ./",
    "RUN go mod download",
    "COPY . .",
    "RUN go build -o server .",
    "",
    "FROM alpine:latest",
    "WORKDIR /app",
    "COPY --from=builder /app/server .",
    `EXPOSE ${appPort}`,
    'CMD ["./server"]',
  ]);
}

// ── Helpers ───────────────────────────────────────────────────────────────────

function lines(arr: string[]): string {
  return arr.join("\n") + "\n";
}

async function fileExists(dir: string, filename: string): Promise<boolean> {
  try {
    await fs.access(path.join(dir, filename));
    return true;
  } catch {
    return false;
  }
}
